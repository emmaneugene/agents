#!/usr/bin/env python3
"""Publish a markdown file as a GitHub Gist, embedding referenced local images and GIFs.

Since `gh gist create` doesn't support binary files, this script creates the
gist with just the markdown, then clones the gist's git repo, adds the image
files, pushes, and rewrites the markdown to use raw GitHub URLs.
"""

import argparse
import datetime
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile
import urllib.parse
import webbrowser


def run(cmd, check=True, cwd=None):
    """Run a shell command and return stdout."""
    result = subprocess.run(cmd, capture_output=True, text=True, cwd=cwd)
    if check and result.returncode != 0:
        print(f"Error running: {' '.join(cmd)}", file=sys.stderr)
        if result.stderr:
            print(result.stderr.strip(), file=sys.stderr)
        sys.exit(1)
    return result.stdout.strip()


def check_dependencies():
    for cmd in ("gh", "git"):
        if not shutil.which(cmd):
            print(f"Error: '{cmd}' is required but not found.", file=sys.stderr)
            sys.exit(1)
    result = subprocess.run(["gh", "auth", "status"], capture_output=True)
    if result.returncode != 0:
        print("Error: Not authenticated with gh. Run 'gh auth login' first.", file=sys.stderr)
        sys.exit(1)


def find_local_image_refs(content):
    """Extract local image/gif paths from markdown and HTML img tags."""
    refs = []

    # ![alt](path) -- but not URLs
    for match in re.finditer(r'!\[[^\]]*\]\(([^)]+)\)', content):
        path = match.group(1)
        if not path.startswith(("http://", "https://")):
            refs.append(path)

    # <img ... src="path" ...> -- but not URLs
    for match in re.finditer(r'<img[^>]+src=["\']([^"\']+)["\']', content, re.IGNORECASE):
        path = match.group(1)
        if not path.startswith(("http://", "https://")):
            refs.append(path)

    # Deduplicate while preserving order
    seen = set()
    unique = []
    for ref in refs:
        if ref not in seen:
            seen.add(ref)
            unique.append(ref)
    return unique


def sanitize_filename(path, taken):
    """Flatten a path to a gist-safe filename, handling collisions.

    Prefixes with '_' so image files sort after the markdown file in the gist.
    """
    base = "_" + os.path.basename(path).replace(" ", "-")
    if base not in taken:
        taken.add(base)
        return base
    name, ext = os.path.splitext(base)
    counter = 2
    while f"{name}-{counter}{ext}" in taken:
        counter += 1
    result = f"{name}-{counter}{ext}"
    taken.add(result)
    return result


def main():
    parser = argparse.ArgumentParser(description="Publish a markdown file as a GitHub Gist with embedded images.")
    parser.add_argument("markdown_file", help="Path to the markdown file")
    parser.add_argument("--name", help="Custom filename for the gist (default: original filename). The gist title is the first filename alphabetically, so this controls what the gist is called.")
    parser.add_argument("--public", action="store_true", help="Make the gist publicly listed (default: secret)")
    parser.add_argument("--desc", help="Description for the gist")
    parser.add_argument("--web", action="store_true", help="Open the gist in a browser after creation")
    args = parser.parse_args()

    if not os.path.isfile(args.markdown_file):
        print(f"Error: File not found: {args.markdown_file}", file=sys.stderr)
        sys.exit(1)

    check_dependencies()

    md_dir = os.path.dirname(os.path.abspath(args.markdown_file))
    md_basename = os.path.basename(args.markdown_file)
    gist_md_name = args.name if args.name else md_basename
    # Ensure the gist filename ends with .md so GitHub renders it as markdown
    if not gist_md_name.endswith(".md"):
        gist_md_name += ".md"
    # Prepend a datetime stamp so the markdown file sorts first alphabetically.
    # GitHub uses the first filename as the gist title, and digits sort before letters.
    utc_prefix = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H%M%SZ-")
    gist_md_name = utc_prefix + gist_md_name
    with open(args.markdown_file, encoding="utf-8") as handle:
        content = handle.read()
    image_refs = find_local_image_refs(content)

    print(f"Processing: {args.markdown_file}")
    if gist_md_name != md_basename:
        print(f"Gist filename: {gist_md_name}")
    print(f"Found {len(image_refs)} local image reference(s)")

    # Resolve image paths and build rewrite map
    rewrite_map = {}  # original_ref -> sanitized_filename
    resolved_images = {}  # sanitized_filename -> absolute_path
    taken_names = set()

    for ref in image_refs:
        # Decode percent-encoded paths (e.g. %20 -> space) for filesystem lookup
        decoded_ref = urllib.parse.unquote(ref)
        full_path = os.path.abspath(os.path.join(md_dir, decoded_ref))
        if os.path.commonpath([md_dir, full_path]) != md_dir:
            print(
                f"  Warning: Referenced image outside markdown directory, skipping: {ref}",
                file=sys.stderr,
            )
            continue
        if not os.path.isfile(full_path):
            print(f"  Warning: Referenced image not found, skipping: {ref}", file=sys.stderr)
            continue
        sanitized = sanitize_filename(decoded_ref, taken_names)
        rewrite_map[ref] = sanitized
        resolved_images[sanitized] = full_path
        print(f"  {ref} -> {sanitized}")

    # Step 1: Create the gist with just the markdown (using the desired filename)
    print("\nCreating gist...")
    with tempfile.TemporaryDirectory() as staging:
        staged_md = os.path.join(staging, gist_md_name)
        shutil.copy2(os.path.abspath(args.markdown_file), staged_md)

        cmd = ["gh", "gist", "create"]
        if args.public:
            cmd.append("--public")
        if args.desc:
            cmd.extend(["--desc", args.desc])
        cmd.append(staged_md)

        gist_url = run(cmd)

    if "gist.github.com" not in gist_url:
        print(f"Error: Unexpected response from gh: {gist_url}", file=sys.stderr)
        sys.exit(1)

    gist_id = gist_url.rstrip("/").split("/")[-1]
    print(f"Gist created: {gist_url}")

    # Step 2: If there are images, clone the gist repo, add them, push, then rewrite URLs
    if rewrite_map:
        clone_dir = tempfile.mkdtemp()
        try:
            print("Cloning gist repo...")
            run(["gh", "gist", "clone", gist_id, clone_dir])

            # Copy images into the cloned repo
            for sanitized, src_path in resolved_images.items():
                shutil.copy2(src_path, os.path.join(clone_dir, sanitized))

            # Commit and push
            run(["git", "add", "."], cwd=clone_dir)
            run(["git", "commit", "-m", "Add images"], cwd=clone_dir)

            print("Pushing images to gist...")
            run(["git", "push"], cwd=clone_dir)

            # Get the gist owner for constructing raw URLs
            gist_json = json.loads(run(["gh", "api", f"gists/{gist_id}"]))
            owner = gist_json.get("owner", {}).get("login", "")

            # Rewrite markdown with raw URLs
            rewritten = content
            for orig_ref, sanitized in rewrite_map.items():
                # Stable raw URL format (no commit SHA, always serves latest)
                encoded_name = urllib.parse.quote(sanitized)
                raw_url = f"https://gist.githubusercontent.com/{owner}/{gist_id}/raw/{encoded_name}"
                escaped_ref = re.escape(orig_ref)
                rewritten = re.sub(
                    rf"(!\[[^\]]*\]\()({escaped_ref})(\))",
                    rf"\1{raw_url}\3",
                    rewritten,
                )
                rewritten = re.sub(
                    rf"(<img[^>]+src=[\"\'])({escaped_ref})([\"\'])",
                    rf"\1{raw_url}\3",
                    rewritten,
                    flags=re.IGNORECASE,
                )

            # Write the rewritten markdown and update the gist
            rewritten_path = os.path.join(clone_dir, gist_md_name)
            with open(rewritten_path, "w", encoding="utf-8") as handle:
                handle.write(rewritten)

            print("Updating markdown with image URLs...")
            run(["gh", "gist", "edit", gist_id, "-f", gist_md_name, rewritten_path])
            print("Gist updated with embedded image URLs")

        finally:
            shutil.rmtree(clone_dir, ignore_errors=True)

    print(f"\nDone! Gist URL: {gist_url}")

    if args.web:
        print("Opening in browser...")
        webbrowser.open(gist_url)


if __name__ == "__main__":
    main()
